# MOMA Simulation Engine

[![Crates.io](https://img.shields.io/crates/v/moma_simulation_engine.svg?style=flat-square)](https://crates.io/crates/moma_simulation_engine)
[![Docs.rs](https://img.shields.io/docsrs/moma_simulation_engine?style=flat-square)](https://docs.rs/moma_simulation_engine)
[![License: MIT OR Apache-2.0](https://img.shields.io/badge/license-MIT%20OR%20Apache--2.0-blue?style=flat-square)](https://opensource.org/licenses/MIT)
[![CI](https://github.com/neil-crago/moma_simulation_engine/actions/workflows/rust.yml/badge.svg)](https://github.com/neil-crago/moma_simulation_engine/actions/workflows/rust.yml)

A library for creating and running dynamic systems, such as cellular automata, using the [MOMA (Moving Origin Modular Arithmetic)](https://www.google.com/search?q=https://github.com/Neil-Crago/moma) framework as the core update rule.

This crate provides the tools to build simulations where the evolution of the system is governed by the complex, non-linear, and deterministic patterns generated by MOMA.

-----

## The Core Idea

Most simulations, like cellular automata, use simple, fixed rules to determine the next state of a cell (e.g., "if the left neighbor is black and the right is white, the new cell is black").

The **MOMA Simulation Engine** replaces these simple rules with a `MomaRing`. The state of a cell evolves based on the MOMA residue of its current state, where the "moving origin" is determined by the state of its neighbors.

This introduces a rich, complex, and deeply interconnected dynamic, allowing for the generation of intricate and emergent patterns that are unique to the chosen MOMA strategy.

-----

## Features

  * **`CellularAutomaton`**: A simple 1D cellular automaton that uses MOMA for its update logic.
  * **Strategy-Driven Rules**: The behavior of the simulation is determined by the `OriginStrategy` passed to it. This means you can create vastly different "universes" just by changing the strategy.
  * **Extensible**: Designed to be a foundation for more complex simulations, such as 2D automata or dynamic graph-based systems.

-----

## Getting Started

To use this engine in your own project, add it to your `Cargo.toml`.

```toml
[dependencies]
moma_simulation_engine = "0.2.9" # Or the most recent version
```
or just use ```cargo add moma_simulation_engine``` from the command line.

### Quick Start: Running a 1D Automaton

Here is a simple example of how to create, run, and display a MOMA-powered cellular automaton.

```rust
use moma::strategy;
use moma_simulation_engine::automaton::CellularAutomaton;
use std::{thread, time};

fn main() {
    println!("--- MOMA-Powered 1D Cellular Automaton ---");

    // --- Simulation Parameters ---
    let width = 100;         // Width of the automaton in cells.
    let steps = 200;         // Number of generations to simulate.
    let modulus = 10;        // The number of states for each cell (0-9).
    let delay_ms = 50;       // Delay between steps for visualization.

    // Choose a MOMA strategy to govern the rules.
    // Try changing this to `strategy::PrimeGap` to see a different universe!
    let strategy = strategy::CompositeMass;

    // --- Initialization ---
    let mut automaton = CellularAutomaton::new(width, modulus, strategy);
    println!("Initial State (Generation 0):\n{}\n", automaton.render());

    // --- Simulation Loop ---
    for i in 1..=steps {
        automaton.step();
        println!("Generation {}:", i);
        println!("{}", automaton.render());
        thread::sleep(time::Duration::from_millis(delay_ms));
    }

    println!("\n--- Simulation Complete ---");
}
```

-----

## Current Examples

This crate is the first step in exploring MOMA as a tool for modeling complex systems. 

The examples directory includes:

  * **moma_automaton** - 1D Cellular Automata.
  * **moma_conways_game_of_life** - 2D Cellular Automata.
  * **Moma_pathfinder** - A static Graph model 
  * **moma_dynamic_pathfinder** - A Dynamic Graph model where node states are updated via MOMA rules.
  * **moma_gower** - An experimental simulation in Rust demonstrating a self-regulating AI agent. This project uses an A\* pathfinding algorithm to navigate a dynamic, procedurally generated world. The agent's decision-making is governed by a **MOMA (Multi-Objective Meta-Observer Architecture)** feedback loop, which uses **Gowers Uniformity Norms** to analyze the geometric complexity of its own solution paths and adapt its strategy in real-time.
  * **moma_network_flow_manager** - An experimental simulation in Rust demonstrating a self-regulating system that manages network flow. This project showcases an agent that uses a **MOMA (Moving Origin Modular Arithmetic)** inspired architecture to achieve a high-level, abstract goal. Instead of simply maximizing flow, the agent dynamically adjusts its strategy to maintain a target level of "resilience" or "structural complexity" in its chosen paths, a property measured quantitatively using **Gowers Uniformity Norms**.
  * **moma_agent_behavioural_analysis** - This is an experiment wherein different MOMA Origin Strategies will produce quantitatively different "personalities" in the agent. We can measure this personality by observing the trade-offs it makes between path efficiency (length) and path complexity (Gowers norm). It was a necessary first step before attempting the **moma_network_flow_manager.**
  * **moma_quantum_simulator** - A simple, educational quantum circuit simulator built in Rust from first principles. This project demonstrates the core concepts of quantum computing, including superposition, entanglement, and measurement, through a clean, step-by-step implementation.

## License

This project is licensed under either of:

  * Apache License, Version 2.0
  * MIT license

at your option. 
